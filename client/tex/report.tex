\documentclass[a4paper,12pt]{report}

\input{header.tex}


\title{Расчетно-Пояснительная Записка \\ 
    \large к курсовой работе на тему: \\ Клиентская часть MTA SMTP}
\author{Яковлева Ольга Викторовна}

\begin{document}

\maketitle


\tableofcontents

\clearpage
\chapter*{Введение}
\addcontentsline{toc}{chapter}{Введение}

Данная расчетно-пояснительная записка содержит информацию о протоколе SMTP (англ. \textbf{S}imple \textbf{M}ail \textbf{T}ransfer \textbf{P}rotocol) и реализации клиентской части MTA (англ. \textbf{M}essage \textbf{T}ransfer \textbf{A}gent) SMTP в рамках курсовой работы.

Содержание работы: проектирование, реализация и тестирование SMTP-клиента (как части MTA), обеспечивающего удаленную доставку и поддерживающего очереди сообщений. Дополнительные условия:
\begin{itemize}
\item Используется системный вызов \texttt{select()};
\item Используется несколько рабочих процессов;
\item Журналирование в отдельном процессе;
\item Пытаться отправлять все сообщения для одного MX за одну сессию.
\end{itemize}

Цель работы: реализовать клиентскую часть MTA SMTP.

Основные задачи:
\begin{enumerate}
    \item Анализ и изучение протокола SMTP, способов мультиплексирования;
    \item Программная реализация SMTP клиента на языке программирования Си под Unix-подобные операционные системы;
    \item Тестирование и отладка написанного клиента;
    \item Оформление расчетно-пояснительной записки по результатам работы.
\end{enumerate}


\chapter{Аналитический раздел}


\section{Протокол SMTP}

SMTP (англ. \textbf{S}imple \textbf{M}ail \textbf{T}ransfer \textbf{P}rotocol) ~-- это широко используемый сетевой протокол, предназначенный для передачи писем электронной почты в сетях TCP/IP. SMTP впервые был описан в RFC 821 (1982 год), а последнее обновление описано в RFC 5321 (2008 год) и включает масштабируемое расширение протокола — ESMTP (Extended SMTP). В настоящее время под протоколом SMTP подразумеваются и его расширения. Протокол SMTP предназначен для передачи исходящей почты с использованием порта TCP 25.

Взаимодействие в рамках SMTP строится по принципу двусторонней связи, которая устанавливается между отправителем и получателем почтового сообщения. При этом отправитель инициирует соединение и посылает запросы, а получатель - отвечает на эти запросы. Таким образом, отправитель выступает в роли клиента, а получатель - сервера.


\subsection{Базовые команды SMTP}

Каждая команда SMTP начинается с ключевого слова – названия команды, указывающего какую операцию хочет произвести клиент. За ним могут следовать параметры, отделенные пробелом. Конец строк в протоколе SMTP обозначается последовательностью символов "возврат каретки"\ (\textbackslash r) и "перевод строки"\ (\textbackslash n) - эта последовательность обозначается CRLF. Сервер начинает выполнение команды только получив от клиента строку, завершающуюся последовательностью CRLF. 

Обычный ответ SMTP сервера на команды клиента состоит из номера ответа, за которым через пробел следует дополнительный текст. Номер ответа служит индикатором состояния сервера и делится на четыре группы:
\begin{itemize}
    \item Команда выполнена успешно (код 2xx);
    \item Промежуточный положительный результат. Команда принята, но сервер ожидает от клиента дополнительные данные для завершения операции (код 3xx);
    \item Исполнение команды временно невозможно. Команда не может быть выполнена, но проблема может быть устранена (код 4xx);
    \item Исполнение команды невозможно (код 5xx).
\end{itemize}

Если ответ состоит из нескольких строк, то каждая из них начинается номером, который отделяется от сопровождающего текста не пробелом, а символом "минус"\ (-). В последней строке номер отделяется от текста пробелом. Каждая строка ответа, как и строки команд, заканчивается последовательностью CRLF.

Ниже представлен список базовых SMTP-команд:
\begin{itemize}
    \item EHLO доменное\_имя\_клиента CRLF - Открывает ESMTP сессию. В ответ на эту команду сервер сообщает, готов ли он к продолжению диалога.
    \item HELO доменное\_имя\_клиента CRLF - Открывает SMTP сессию. В RFC 2821 рекомендуется использовать команду HELO, только если программное обеспечение не поддерживает команду EHLO. Отличие этой команды только в том, что она делает невозможным использование расширений ESMTP. Передача почты возможна только после выполнения одной из двух перечисленных выше команд.
    \item MAIL FROM: <адрес\_отправителя> CRLF - Сообщает адрес отправителя письма. Для каждого письма команда MAIL должна быть выполнена только один раз. Адрес может быть оставлен пустым: <>. Команда MAIL может быть выполнена только после успешного выполнения команды EHLO или HELO.
    \item RCPT TO: <адрес\_получателя> CRLF - Сообщает адрес получателя письма. Доставка сообщения возможна, только если указан хотя бы один адрес получателя. Команда RCPT принимает в качестве аргумента только один адрес. Если нужно послать письмо большему числу адресатов, то команду RCPT следует повторять для каждого. Команда RCPT может быть выполнена только после успешного выполнения команды MAIL.
    \item DATA CRLF - Определяет начало письма. C помощью этой команды серверу передается текст сообщения, состоящий из заголовка и отделенного от него пустой строкой тела сообщения. В ответ на правильно введенную команду DATA сервер сообщает о готовности к приему или об ошибке, если прием сообщения невозможен. Передача самого сообщения заканчивается строкой, состоящей из одной точки. Эта строка не является частью сообщения и удаляется на приемной стороне. Команда DATA может быть выполнена только после успешного выполнения хотя бы одной команды RCPT.
    \item RSET CRLF - Сброс SMTP соединения. Команда RSET аннулирует все переданные до нее на сервер данные.
    \item VRFY CRLF - Проверяет наличия указанного в качестве аргумента почтового ящика.
    \item QUIT CRLF - Закрыть SMTP сессию. Командой QUIT клиент заканчивает диалог с сервером. Сервер посылает подтверждение и закрывает соединение. Получив это подтверждение, клиент тоже прекращает связь.
\end{itemize}

\section{Плюсы и минусы использования многопроцессорного подхода обработки подключений при помощи мультиплексирования и системного вызова select()}

В рамках задания необходимо реализовать клиентскую часть MTA SMTP с использованием системного вызова \texttt{select()} в нескольких рабочих процессах. К плюсам данного подхода можно отнести:
\begin{itemize}
    \item Возможность распределения нагрузки по нескольким процессам
    \item системный вызов \texttt{select()} удобен для простых задач, не требуется работать с динамической памятью, как в  \texttt{poll()}
\end{itemize}

К недостаткам данного подхода относятся:
\begin{itemize}
    \item Системный вызов \texttt{select()} не способен обрабатывать количество сокетов, большее 1024
    \item Создание отдельных процессов - дополнительные расходы и нагрузка на систему, особенно в случае создания процессов для обработки небольшого количества писем
\end{itemize}


\section{Сущности предметной области}

Сущности предметной области представлены на ER-диаграмме (рис. \ref{fig:er}).

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{dia/ER.pdf}
    \caption{ER-диаграмма предметной области}
    \label{fig:er}
\end{figure}


\chapter{Конструкторский раздел}


\section{Конечный автомат состояний клиента}

На рис.~\ref{fig:fsm} изображен конечный автомат состояний клиентской части MTA SMTP. 

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{include/client_def_dot.pdf}
    \caption{Конечный автомат состояний клиента}
    \label{fig:fsm}
\end{figure}

\section{Описание основных структур данных}

Общие структуры данных:
\begin{itemize}
    \item Соединение на низком уровне (файловый десприптор, тип дескриптора -- pipe или сокет, входной и выходной буферы, входная очередь строк, выходная очередь строк). Все процессы не будут работать с буферами напрямую, а будут использовать очереди строк
    \item Очередь (элементом может быть произвольная структура)
    \item Ассоциативный массив (карта) -- дерево (ключ -- строка, значением может быть произвольная структура)
\end{itemize}

Структуры данных основного процесса:
\begin{itemize}
    \item Рабочий процесс (pid, pipe)
    \item Чтобы можно было эффективно выбрать рабочий процесс, который отправит письмо, родительский процесс хранит карту почтовых хостов (ключ -- хост, значение -- канал рабочего процесса и временная метка последней отправки в канал). То есть хранится информация о том, какой процесс недавно работал с этим хостом.
\end{itemize}

Структуры данных рабочего процесса:
\begin{itemize}
    \item Письмо (почта отправителя, почты получателей, список строк данных)
    \item Чтобы выполнить условие отправки всех писем для одного MX за одну сессию, рабочий процесс хранит карту хостов (ключ -- хост, значение -- соединение с сервером)
    \item Соединение с сервером (состояние конечного автомата, ip сервера, соединение на низком уровне, очередь писем)
\end{itemize}

\section{Алгоритмы работы родительского и рабочих процессов}

Алгоритм работы основного (родительского) процесса:

\begin{verbatim}
    Цикл для каждого рабочего процесса:
        Создать канал (pipe) для общения с процессом
        Запустить процесс
    Пока не пришел SIGINT:
        Считать все имена файлов из очереди сообщения
        Цикл для каждого имени файла:
            Если файл еще не отправлен на обработку:
                Выбрать рабочий процесс
                Отправить рабочему процессу в pipe имя файла
                Сохранить файл в списке отправленных на обработку
\end{verbatim}

Чтобы можно было эффективно выбрать рабочий процесс, который отправит письмо, родительский процесс хранит карту почтовых хостов (ключ -- хост, значение -- канал рабочего процесса и временная метка последней отправки в канал). То есть хранится информация о том, какой процесс недавно работал с этим хостом.

При таком подходе могут возникнуть проблемы, если у письма несколько получателей с разными MX (непонятно, какому процессу в этом случае отправлять файл). Поэтому SMTP-сервер группирует получателей по хостам и на каждый уникальный хост создает хардлинк файла письма. При этом в названии хардлинка указывается в том числе хост. Таким образом родительский процесс, анализируя имя файла письма, сможет однозначно определить, какой рабочий процесс займется отправкой. Рабочие процессы в свою очередь не будут посылать письмо тем получателям, почтовый хост которых не совпадает с указанным в названии файла письма.

Алгоритм выбора рабочего процесса:
\begin{verbatim}
    Вход: имя файла, карта хостов, полный список каналов рабочих процессов
    Выход: канал рабочего процесса, куда надо отправить имя файла
    Алгоритм:
    Определить почтовый хост по имени файла
    Если в карте хостов есть этот хост:
        Если в канал процесса в течение последних N секунд уже были отправлены файлы
            Вернуть этот канал
        Иначе
            Удалить запись из карты
    Иначе
        Выбрать канал из общего списка Round-robin'ом
        Добавить запись о выбранном канале для хоста в карту
        Вернуть выбранный канал
\end{verbatim}

Алгоритм работы рабочих (дочерних) процессов:

\begin{verbatim}
    Пока не пришел SIGINT:
        Ожидание срабатывания select
        Цикл по всем дескрипторам активных соединений (сокеты и канал родителя):
            Если пришло сообщение в канал родителя:
                Считать имена файлов из канала в список
                Для каждого имени файла:
                    Считать письмо из файла в память
                    Определить почтовый хост получателей по названию файла
                    Выбрать активное соединение по хосту
                    Добавить письмо в очередь к отправке по соединению
                    Удалить файл с диска
            Если пришло сообщение на сокет соединения
                Обработать ответ сервера
            Если нужно отправить сообщение серверу
                Отослать сообщение серверу
            Если соединение закрыто
                Удалить его из активных
\end{verbatim}

Чтобы выполнить условие отправки всех писем для одного MX за одну сессию, рабочий процесс хранит карту хостов (ключ -- хост, значение -- соединение с MX)

Алгоритм выбора активного соединения по почтовому хосту
\begin{verbatim}
Вход: почтовый хост, карта хостов
Выход: активное соединение
Алгоритм:
    Если в карте хостов есть этот хост:
        Вернуть значение записи карты для этого хоста
    Иначе
        Создать новое активное соединение
        Добавить запись о созданном соединении в карту
        Вернуть новое соединение
\end{verbatim}


\section{Связь основого процесса, рабочих процессов и процесса журналирования}

Основной процесс взаимодействует с рабочими с помощью pipe (IPC). Все процессы взаимодействуют с процессом журналирования также с помощью pipe (IPC). На рис.~\ref{fig:comm} изображены связи между всеми процессами. Стрелочка показывает направление передачи данных. 

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{include/processes_dot.pdf}
    \caption{Связи между процессами}
    \label{fig:comm}
\end{figure}

\section{Хранение почты}

Для хранения локальной почты, то есть предназначенной для клиентов с почтовым хостом сервера, используется упрощенный формат Maildir. Maildir - формат хранения электронной почты, не требующий монопольного захвата файла для обеспечения целостности почтового ящика при чтении, добавлении или изменении сообщений. Каждое сообщение хранится в отдельном файле с уникальным именем, а каждая папка представляет собой каталог. Вопросами блокировки файлов при добавлении, перемещении и удалении файлов занимается локальная файловая система. Все изменения делаются при помощи атомарных файловых операций, таким образом, монопольный захват файла ни в каком случае не нужен.

Для почты, предназначенной другим почтовым серверам также используется файловая система. Каждое сообщение аналогично хранится в отдельном файле с уникальным именем. Первоначально файл заполняется во временном месте, чтобы клиент не мог его прочитать, пока тот не будет полностью записан. Затем файл переносится в отдельную заранее указанную директорию, из которой в дальнейшем клиент считывает письма для их пересылки. 

Имя файла формируется по следующему шаблону: хост-получатель.тип.уникальный\_идентификатор. Где тип 0 означает, что IP-адрес сервера-получателя задан в формате IPv4, 1 -- в формате IPv6, 2 -- известен только хост, например, yandex.ru.


\chapter{Технологический раздел}


\section{Написание исходного кода}

Для написания исходного кода клиентской части MTA SMTP использовался язык C стандарта C99 со стандартными системными библиотеками (ввода/вывода, сокетов, строк, времени, сигналов и т.д.), а так же дополнительными библиотеками и утилитами такими как:
\begin{itemize}
    \item Autoopts - для автоматической генерации кода чтения параметров командной строки.
    \item Autofsm - для автоматической генерации конечного автомата состояний клиента.
    \item CUnit - для модульного тестирования написанного кода приложения.
\end{itemize}


\section{Платформы и компиляторы}

Разработанное приложение SMTP клиента проверялось на операционной системе Ubuntu-18.04 с использованием компилятора GCC и стандарта языка Си C99.


\section{Сборка программы}

Сборка SMTP клиента описана в файле \texttt{Makefile} системы сборки \texttt{make}.

Сборка выполняется командой:
\begin{verbatim}
    make client
\end{verbatim}


\section{Основные функции программы}

Данный раздел сгеренерирован при помощи doxygen из части комментированных исходников программы. В файле конфигурации \textbf{doxyggen.cfg} был отключён параметр \textbf{HAVE\_DOT}, поскольку для рисования графов вызовов используется \textit{cflow}.

Здесь описываются основные функции клиента, отвечающие за его работоспособность.

\input{include/master_8c.tex}
\input{include/worker_8c.tex}
\input{include/fileparser_8c.tex}
\input{include/SMTP__connection_8c.tex}


\section{Основные структуры программы}

Данный раздел аналогично прошлому сгеренерирован при помощи doxygen и описывает основные структуры, использующиеся в коде клиента и на которые ссылаются его основные функции.

\input{include/structpeer____t.tex}
\input{include/structSMTP__message____t.tex}
\input{include/structSMTP__connection____t.tex}


\section{Описание параметров командной строки}

Ниже приведено описание используемых клиентом обязательных и необязательных параметров командной строки в формате autoopts:
\input{include/checkoptn.def.tex}


\section{Графы вызова функций}

Графы вызова функций разбиты на два рисунка. Ниже на рис.~\ref{fig:cflow1} показаны основные функция рабочего процесса. На рис.~\ref{fig:cflow2} в свою очередь показаны функции обработки ответов от сервера и конечного автомата состояний подключения.

\begin{figure}[h]
\includegraphics[width=1.1\textwidth]{include/cflow01_dot.pdf}
\caption{Граф вызовов. Основная функция рабочего процесса}
\label{fig:cflow1}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=\textwidth]{include/cflow02_dot.pdf}
\caption{Граф вызовов. Функции обработки команд}
\label{fig:cflow2}
\end{figure}

Сами графы были созданы с помощью утилит \texttt{cflow}, \texttt{cflow2dot} и \texttt{dot}.


\section{Модульное тестирование}

Для модульного тестирования функций клиента в работе используется библиотека CUnit. Тестировались основные модули, такие как: модуль работы с файлами (функции чтения писем, получения хоста по названию письма), модуль работы с соединением на низком уровне (функции считывания выходного буфера в очередь строк, считывания очереди строк во входной буфер, добавления сообщения с маркером конца строки во входную очередь). Для каждого из них было написано несколько тестов с ассертами. Ниже приведены сводные результаты тестирования:
\begin{verbatim}
    Run Summary:    Type  Total    Ran Passed Failed Inactive
              suites      2      2    n/a      0        0
               tests     11     11     11      0        0
             asserts     37     37     37      0      n/a

Elapsed time =    0.000 seconds
Exiting tests
\end{verbatim}



\section{Тестирование утечек памяти}

Для тестирования утечек памяти использовалась утилита valgrind. По результатам тестов она не обнаружила никаких потенциально возможных мест с утечками памяти. Окончательные результаты ее работы приведены ниже:
\begin{verbatim}
    ==1533== LEAK SUMMARY:
    ==1533==    definitely lost: 0 bytes in 0 blocks
    ==1533==    indirectly lost: 0 bytes in 0 blocks
    ==1533==      possibly lost: 0 bytes in 0 blocks
    ==1533==    still reachable: 4,192 bytes in 4 blocks
    ==1533==         suppressed: 0 bytes in 0 blocks

\end{verbatim}


\clearpage
\chapter*{Заключение}
\addcontentsline{toc}{chapter}{Заключение}

В процессе выполнения работы была написана программная реализация клиентской части MTA SMTP. Был изучен протокол передачи электронной почты SMTP и способы мультиплексирования. Были закреплены и получены навыки в написании сетевых приложений на языке Си для Unix-подобных операционных систем. Было проведено тестирование и отладка разработанного приложения и в итоге по результатам проведенной работы была оформлена расчетно-пояснительная записка.

\end{document}
